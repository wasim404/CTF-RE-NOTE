【逆向】RC4加密

# RC4核心

RC4 由两个核心部分组成：

| 缩写     | 全称                               | 功能                                              |
| -------- | ---------------------------------- | ------------------------------------------------- |
| **KSA**  | Key Scheduling Algorithm           | 根据密钥初始化 S-box（状态数组 S）                |
| **PRGA** | Pseudo-Random Generation Algorithm | 用 S-box 生成**伪随机密钥流**，并与数据异或加解密 |

RC4 是**对称流密码**：加密和解密过程完全一样，只是用同样的密钥流异或。

## KSA

**功能**：用密钥**打乱**一个初始状态数组 S（0~255 的排列），为生成密钥流做准备。

### 流程（256 轮初始化）

1. 初始化 S 数组：

   ```c
   S[i] = i   (i=0..255)
   ```

2. 用密钥打乱：

   ```c
   j = 0
   for i in 0..255:
       j = (j + S[i] + key[i % keylen]) % 256
       swap(S[i], S[j])
   ```

📌 **在汇编/反编译中如何认出来**：

- 有一个长度为 **256** 的数组（通常是 `int v[256]` 或 `unsigned char S[256]`）被填充为 `0..255`
- 有两个循环变量 `i` 和 `j`
- 会频繁出现 `j = (j + S[i] + key[...]) % 256` 这种加法取模（或直接用 unsigned char 截断）
- 有很多 `swap(S[i], S[j])`

------

## PRGA

**功能**：在加密/解密过程中，利用 S 数组生成密钥流字节，并与数据异或。

### 流程（每个字节一轮）

```c
i = j = 0
for each byte in plaintext/ciphertext:
    i = (i + 1) % 256
    j = (j + S[i]) % 256
    swap(S[i], S[j])
    K = S[(S[i] + S[j]) % 256]   // 生成一个密钥流字节
    output_byte = input_byte ^ K
```

📌 **特征**：

- 有两个累加变量
- 每轮都会 `swap(S[i], S[j])`
- 最后用 `S[(S[i] + S[j]) % 256]` 取出一个字节做 XOR
- 输入和输出是同一块缓冲区（加解密通用）

## RC4 的主要特征总结

在逆向时，你可以根据以下特征锁定 RC4：

1. **256 大小的 S 数组初始化为 0~255**
2. **KSA 阶段**：有两个循环
3. **PRGA 阶段**：两个累加变量 `i` / `j`（或类似命名），每轮交换 S[i] 和 S[j]
4. **密钥流生成**：用 `(S[i] + S[j]) % 256` 取索引
5. **与数据异或**：`data ^= keybyte`，且加密解密函数几乎一样

------

## 在这道题里的流程

1. `sub_140001120` 用 `Str = "12345678abcdefghijklmnopqrspxyz"` 初始化 RC4 S-box（KSA）
2. `sub_140001240` 用这个 S-box 生成密钥流，对你的输入 `v10` 进行加密/解密（PRGA）
3. 再把处理后的 `v10` 与 0x22 异或，和 `byte_14013B000` 比较
4. 所以要解题：
   - 先对 `byte_14013B000[i] ^ 0x22` 得到密文
   - 再用 RC4( key=Str ) 解密密文，得到真正的输入