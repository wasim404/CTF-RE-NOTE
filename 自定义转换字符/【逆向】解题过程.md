# 【逆向】解题过程

## 流程分析

### sub_1400010E0函数

```c
void __fastcall __noreturn sub_1400010E0(char *a1, __int64 a2)
{
  int v2; // r9d
  __int64 v3; // r8
  char *v4; // r10
  char v5; // al
  __int64 v6; // rbx
  unsigned __int8 v7; // cl
  char v8; // [rsp+1Fh] [rbp-3F9h]
  char v9; // [rsp+20h] [rbp-3F8h] BYREF

  v2 = 0;
  v3 = (__int64)a1;
  if ( a1 )
  {
    v4 = &v9;
    do
    {
      ++v4;
      ++v2;
      a1 = &a4890572163qwe[-26 * (v3 / 26)];
      v5 = a1[v3];
      v3 /= 26i64;
      a2 = v3;
      *(v4 - 1) = v5;
    }
    while ( v3 );
  }
  v6 = v2;
  while ( v6 )
  {
    v7 = *(&v8 + v6--);
    sub_1400011E0(v7 ^ 7u, a2, v3);
  }
  sub_140001220(a1, a2, v3);
}
```

`__fastcall`意味着函数传参尽可能地通过CPU的寄存器而并不是栈。

`__noreturn`意味着函数永远不会返回，一旦 main 函数被调用，它要么会进入一个无限循环，要么会调用一个退出程序的函数（如 exit()），但它绝不会执行到 return 语句。

查询`a4890572163qwe` ，可知储存内容为`)(*&^%489$!057@#><:2163qwe`

接下来是分析`a1 = &a4890572163qwe[-26 * (v3 / 26)];
      v5 = a1[v3];`这两句的功能

先说结论，这两句实现的效果是`v5 = key_str[v3 % 26];`

首先，根据C语言数组的储存特点

``a1 = &a4890572163qwe[-26 * (v3 / 26)]` 实际上等于 ` a1=a4890572163qwe-26*(v3/26)`

` a1[v3];`等于`*(a1+v3)`

结合这两步综合就是，`a4890572163qwe-26*(v3/26)+v3`

调换一下顺序，也就是`a4890572163qwe+v3-26*(v3/26)`

也就是说`v5=a4890572163qwe[v3-26*(v3/26)]`

这里讲一下商和余数的关系，设`q=v3/26 r=v3%26`，那么`v3-26*(v3/26)=v3-26*q`，又因为`v3=26*q+r`（被除数等于除数乘以商加上余数）。那么`v3-26*(v3/26)=r=v3%26`

综上所述，`v5=a4890572163qwe[v3%26]`

1. `v3 % 26` → **取余数**，得到当前“26 进制最低位”对应的字符下标。
2. `v3 /= 26` → **除以 26**，去掉最低位，准备处理下一位。
3. 循环结束 → 所有余数都被取出 → 形成了完整的 **26 进制展开**。

所以这个循环就是 **把十进制数字拆分成 26 进制的每一位**，再映射到 `key_str` 的字符。

### sub_1400011E0函数

执行完前面步骤后，进入sub_1400011E0函数，这是一个链表插入函数。

### sub_140001220(a1, a2, v3)函数

在IDA中进行动态调试，发现sub_1400012E0()是成功处理函数，sub_1400012B0()是失败函数。也就是说我们现在目标是让**v7==14**

从代码看，`v7` 只有在 **链表里的字符 == 目标串 `aV4pY59[...]`** 时才会增加。
 每轮循环比对两个字符：

- 第一个节点 → `aV4pY59[v2 - 1]`
- 第二个节点 → `aV4pY59[v2]`

只有当 **链表节点字符 == `aV4pY59` 对应位置的字符** （..v4p$$!>Y59-）时，计数 `v7` 才会累积。

最终 `v7` 必须增加 14 次 → **链表里必须顺序存储目标串的 14 个字符**。

# 过程

**你的输入（数字） → 26 进制分解 → )(*&^%489$!057@#><:2163qwe → XOR 7 → 存到链表 → 验证是否等于 `..v4p$$!>Y59-`**。

输入这个数字时，程序会：

- 拆分成 26 进制 → 从 `key_str` 取字符 → 每位 XOR 7 → 存入链表 → 与 `aV4pY59[...]` 完全一致。
- 最后 `v7 == 14`，触发 `sub_1400012E0()`（也就是通过条件，输出 flag 或进入正确逻辑）。

那么解题脚本就是

```python
str1 = '/..v4p$$!>Y59-'
str2 = ')(*&^%489$!057@#><:2163qwe'
list_data = []
for i, c in enumerate(str1):
    data = chr(ord(c) ^ 7) //得到原本储存进去的字符
    data = str2.find(data)
    list_data.append(data)

res = 0
for i, c in enumerate(list_data):
    res *= 26
    res += c

print(res)
```



